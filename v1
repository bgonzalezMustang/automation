
# Import pdfreader for reading
import pdfreader
from pdfreader import SimplePDFViewer

# Import re for regex manipulation
import re

from pdfreader.viewer.pdfviewer import PagesIterator


# These are test files. Comment or uncomment the one you want to use.
file = "3866-A-R-0BRK- MILESTONE- 108 HEDGE GREEN HOLLOW-LANDSCAPE.pdf"
# file = "5161-COLINAS II-D-4BRK-DREES-517 FRANCIS COURT.pdf"
# file = "108 HEDGE GREEN HOLLOW MARKED PLANS.pdf"

# Make sure this path goes to where your relevant files are
path = "C:/Users/dwanegar/Documents/Python Scripts/testFiles/" + file


# Setup
pdfFileObj = open(path, 'rb')
viewer = SimplePDFViewer(pdfFileObj)

# These regexes could probably be improved. I imagine there are scenarios that break them. Maybe we just fix them as issues are discovered?
fixtureRegexesFiveSet = [
    re.compile(r"(?:c|ow|tw|overall|\d+\'-\d+(?:1\/2)?\")"), #This needs to be tested better
    re.compile(r"\d+\'-\d+(?:1\/2)?\""),
    re.compile(r"(?:c|ow|tw)"),
    re.compile(r"\d+\'-\d+(?:1\/2)?\""),
    re.compile(r"(?:c|ow|tw)")
]

fixtureRegexesThreeSet = [
    re.compile(r"(?:c|ow|tw|\d+\'(?:-\d+(?:1\/2)?\")?(?:c|ow|tw|overall))"),
    re.compile(r"\d+\'-\d+(?:1\/2)?\"(?:c|ow|tw)"),
    re.compile(r"\d+\'-\d+(?:1\/2)?\"(?:c|ow|tw)")
]


def fixtureDetectorFiveString(stringSet):
    isFixture = True
    if fixtureRegexesFiveSet[0].match(stringSet[0]):
        isFixture = False
    for i in range(1,4):
        if not fixtureRegexesFiveSet[i].match(stringSet[i]):
            isFixture = False
            break
    return isFixture

# Detects if given input is a fixture based on the following two or four


def fixtureDetector(stringSet):
    isFixture = True
    if fixtureRegexesThreeSet[0].match(stringSet[0]):
        isFixture = False
    for i in range(1, 3):
        if not fixtureRegexesThreeSet[i].match(stringSet[i]):
            isFixture = False
            break
    if isFixture:
        return isFixture
    if (len(stringSet) > 4):
        isFixture = fixtureDetectorFiveString(stringSet)
    return isFixture


def columnTitleDetector(stringSet):
    return stringSet == ["FIXTURE", "DOWNPULL", "SIDEPULL"]


longTextRegex = re.compile(r"[\w\s]{10,}")
# Verifies 3" stack is actually part of a table


def verifyStack(stringSet):
    startIndex = len(stringSet)-3
    if (longTextRegex.search(stringSet[-1])):
        startIndex -= 1
        if startIndex < 0:
            startIndex = 0
    if fixtureDetector(stringSet[startIndex:startIndex+3]) or columnTitleDetector(stringSet[startIndex:startIndex+3]):
        return True
    if len(stringSet) > 4:
        startIndex -= 2
        if startIndex < 0:
            startIndex = 0
        if fixtureDetectorFiveString(stringSet[startIndex:startIndex+5]):
            return True
    return False


# The mandatory room types require minimum one of each type, but any one of a given type will do
kitchen = ["KITCHEN"]
bath = ["BATH", "POWDER", "UTILITY"]
mandatoryRoomTypes = [kitchen, bath]

# Convert mandatoryRoomTypes to a regex list
mandatoryRoomRegexes = []
# Add list of rooms successfully verified in tables
roomVerification = []
for roomType in mandatoryRoomTypes:
    # This looks like r"(?=(ROOM1|ROOM2|ROOM3))"
    roomTypeRegex = r"("+'|'.join(roomType)+r")"
    mandatoryRoomRegexes.append(roomTypeRegex)
    roomVerification.append(False)

# Starts in a "pass" state. Failing at any point changes this to failTest = True
failTest = False

# Whenever any event would cause failTest = True, a relevant string is added to the failLog
failLog = []

# List of fixtures generated by above function, fixtureDetector()
fixtureList = []
threeInchStackIndices = []

# canvases are pages in a pdf, I think? Regardless, iterate over these
for canvas in viewer:
    # Get the list of strings in the canvas. These are ordered by the method the pdf was written, not how it is viewed.
    page_strings = canvas.strings
    # This print line is not necessary to run. It is here for debugging.
    print(page_strings)
    for i in range(len(mandatoryRoomRegexes)):
        roomTypeRegex = mandatoryRoomRegexes[i]
        r = re.compile(roomTypeRegex)
        # Print is for debugging purposes
        # print(roomTypeRegex)
        if len(page_strings) > 1:
            for j in range(len(page_strings)-1):
                if (r.search(page_strings[j]) and page_strings[j+1] == "FIXTURE"):
                    # Print is for debugging purposes
                    # print(page_strings[j])
                    roomVerification[i] = True
    # This should generate the list of all the detected fixtures
    if len(page_strings) > 2:
        if len(page_strings) > 4:
            for j in range(len(page_strings)-4):
                if(fixtureDetector(page_strings[j:j+5])):
                    isFixture = True
                    if(page_strings[j] == "3\" STACK"):
                        isFixture = verifyStack(page_strings[max(j-6, 0):j])
                    if isFixture:
                        fixtureList.append(page_strings[j])
                        print(page_strings[j:j+5])
        for j in range(2):
            if(fixtureDetector(page_strings[-4+j:])):
                isFixture = True
                if(page_strings[j] == "3\" STACK"):
                    isFixture = verifyStack(page_strings[max(j-6, 0):j])
                if isFixture:
                    fixtureList.append(page_strings[-4+j])
                    print(page_strings[-4+j:])


# If any room hasn't been verified, fail the test. Append the failLog for each.
for i in range(len(roomVerification)):
    if not roomVerification[i]:
        failTest = True
        failLog.append(mandatoryRoomRegexes[i])

# Finish the program based on test results.
if failTest:
    # add code to print failLog lines to a file
    print("Test failed, see log")
    print("fail log:")
    print(failLog)
else:
    print("Good job")

print("The following " + str(len(fixtureList)) + " fixtures were detected:")
print(fixtureList)
